/*
 * Copyright (c) 2017 Claudiu Soroiu
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ro.derbederos.untwist;

import org.apache.commons.math3.exception.OutOfRangeException;
import org.apache.commons.math3.random.BitsStreamGenerator;

import static java.lang.Integer.toUnsignedLong;

public abstract class ReverseBitsStreamGenerator extends BitsStreamGenerator implements ReverseRandomGenerator {
    private static final long serialVersionUID = 1L;

    // the state of the generator
    private boolean shouldReverseGaussian;

    /**
     * {@inheritDoc}
     */
    @Override
    protected abstract int next(int bits);

    /**
     * The reverse of {@link #next(int)}.
     * <p>
     * Generate previous pseudorandom number.
     * <p>
     * This method is the core generation algorithm.
     *
     * @param bits number of random bits to produce
     * @return random bits generated
     */
    protected abstract int prev(int bits);

    /**
     * {@inheritDoc}
     */
    @Override
    public void prevBytes(byte[] bytes) {
        prevBytesFill(bytes, 0, bytes.length);
    }

    /**
     * The reverse of {@link #nextBytes(byte[], int, int)}.
     *
     * @param bytes the non-null byte array in which to put the random byte.
     * @param start index at which to start inserting the generated bytes.
     * @param len   number of bytes to insert.
     */
    public void prevBytes(byte[] bytes, int start, int len) {
        if (start < 0 ||
                start >= bytes.length) {
            throw new OutOfRangeException(start, 0, bytes.length);
        }
        if (len < 0 ||
                len > bytes.length - start) {
            throw new OutOfRangeException(len, 0, bytes.length - start);
        }

        prevBytesFill(bytes, start, len);
    }

    private void prevBytesFill(byte[] bytes,
                               int start,
                               int len) {
        final int bytesInInt = Integer.SIZE / Byte.SIZE;
        final int remainder = bytes.length % bytesInInt;
        if (remainder > 0) {
            for (int i = remainder - 1,
                 rnd = prevInt();
                 i >= 0; i--, rnd >>= Byte.SIZE) {
                bytes[i + start] = (byte) (rnd);
            }
        }
        for (int i = remainder + start, indexLimit = start + len; i < indexLimit; ) {
            for (int rnd = prevInt(),
                 n = bytesInInt;
                 n-- > 0; rnd <<= Byte.SIZE) {
                bytes[i++] = (byte) (rnd >>> 24);
            }
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int prevInt() {
        return prev(32);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int prevInt(int bound) {
        if (bound <= 0) {
            throw new IllegalArgumentException("bound must be positive");
        }

        if ((bound & -bound) == bound) {
            return (int) (((long) bound * prev(31)) >> 31);
        }

        int bits, val;
        do {
            bits = prev(31);
            val = bits % bound;
        } while (bits - val + (bound - 1) < 0);
        return val;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public long prevLong() {
        long low = toUnsignedLong(prev(32));
        long high = toUnsignedLong(prev(32)) << 32;
        return low | high;
    }

    /**
     * The reverse of {@link #nextLong(long)}.
     *
     * @param bound the bound on the random number to be returned. Must be positive.
     * @return the previous pseudorandom, uniformly distributed {@code long} value between
     * {@code 0} (inclusive) and {@code bound} <code>bound</code> (exclusive).
     */
    public long prevLong(long bound) throws IllegalArgumentException {
        if (bound <= 0) {
            throw new IllegalArgumentException("bound must be positive");
        }

        long bits, val;
        do {
            bits = toUnsignedLong(prev(32));
            bits |= toUnsignedLong(prev(31)) << 32;
            val = bits % bound;
        } while ((bits - val) + (bound - 1) < 0);
        return val;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean prevBoolean() {
        return prev(1) != 0;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public float prevFloat() {
        return prev(23) * 0x1.0p-23f;

    }

    /**
     * {@inheritDoc}
     */
    @Override
    public double prevDouble() {
        final int low = prev(26);
        final long high = ((long) prev(26)) << 26;
        return (low | high) * 0x1.0p-52d;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void clear() {
        super.clear();
        shouldReverseGaussian = false;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public double nextGaussian() {
        shouldReverseGaussian = !shouldReverseGaussian;
        return super.nextGaussian();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void undoNextGaussian() {
        if (shouldReverseGaussian) {
            prevDouble();
            prevDouble();
            clear();
        } else {
            shouldReverseGaussian = true;
        }
    }
}
